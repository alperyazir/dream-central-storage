# Story 10.2: TTS Provider Abstraction Layer

## Status
Done

## Story
**As a** system developer,
**I want** an abstracted TTS (Text-to-Speech) service layer with multiple provider support,
**so that** the AI processing pipeline can generate audio pronunciations using different TTS providers interchangeably with automatic fallback capabilities.

## Acceptance Criteria
1. Abstract interface for TTS providers (protocol/base class with standard methods)
2. Edge TTS provider implementation (primary, free - no API key required)
3. Azure TTS provider implementation (fallback, requires API key)
4. Multi-language voice selection (configurable voices per language)
5. Batch processing support (generate multiple audio files efficiently)
6. Audio format configuration (MP3 output with quality settings)

## Tasks / Subtasks

- [x] Task 1: Create TTS provider base interface (AC: 1)
  - [x] Create `apps/api/app/services/tts/__init__.py` module
  - [x] Define `TTSProvider` ABC with standard methods: `synthesize()`, `synthesize_batch()`
  - [x] Define request/response models: `TTSRequest`, `TTSResponse`, `TTSVoice`
  - [x] Define provider-specific exceptions: `TTSProviderError`, `TTSRateLimitError`, `TTSAuthError`
  - [x] Define `TTSProviderType` enum for provider types

- [x] Task 2: Implement Edge TTS provider (AC: 2)
  - [x] Create `apps/api/app/services/tts/edge.py`
  - [x] Install `edge-tts` package (add to requirements)
  - [x] Implement `EdgeTTSProvider` class conforming to `TTSProvider` interface
  - [x] Implement `synthesize()` method for single text-to-speech
  - [x] Implement `synthesize_batch()` for multiple items
  - [x] Support voice selection by language code
  - [x] Return audio as bytes (MP3 format)

- [x] Task 3: Implement Azure TTS provider (AC: 3)
  - [x] Create `apps/api/app/services/tts/azure.py`
  - [x] Implement `AzureTTSProvider` class conforming to `TTSProvider` interface
  - [x] Implement `synthesize()` method using Azure Cognitive Services
  - [x] Implement `synthesize_batch()` for multiple items
  - [x] Handle API authentication and errors
  - [x] Support voice selection by language code

- [x] Task 4: Add environment configuration (AC: 4, 6)
  - [x] Add TTS settings to `apps/api/app/core/config.py`
  - [x] Add `DCS_AZURE_TTS_KEY`, `DCS_AZURE_TTS_REGION` environment variables
  - [x] Add `DCS_TTS_PRIMARY_PROVIDER`, `DCS_TTS_FALLBACK_PROVIDER` settings
  - [x] Add `DCS_TTS_AUDIO_FORMAT` setting (default: mp3)
  - [x] Add `DCS_TTS_DEFAULT_VOICE_EN`, `DCS_TTS_DEFAULT_VOICE_TR` settings
  - [x] Add timeout and retry settings

- [x] Task 5: Implement TTS service with fallback logic (AC: 1, 2, 3)
  - [x] Create `apps/api/app/services/tts/service.py`
  - [x] Implement `TTSService` class that wraps providers
  - [x] Implement provider factory method based on configuration
  - [x] Implement automatic fallback: try primary (Edge), on failure try fallback (Azure)
  - [x] Implement configurable retry logic with exponential backoff
  - [x] Log provider switches and failures

- [x] Task 6: Implement multi-language voice mapping (AC: 4)
  - [x] Create voice configuration mapping in `base.py`
  - [x] Define default voices per language for each provider:
    - English: `en-US-JennyNeural` (Edge), `en-US-JennyNeural` (Azure)
    - Turkish: `tr-TR-EmelNeural` (Edge), `tr-TR-EmelNeural` (Azure)
  - [x] Implement voice lookup by language code
  - [x] Allow voice override in TTSRequest

- [x] Task 7: Implement batch processing (AC: 5)
  - [x] Add `synthesize_batch()` to TTSService
  - [x] Implement concurrent processing with configurable concurrency limit
  - [x] Handle partial failures (some items fail, others succeed)
  - [x] Return results with success/failure status per item
  - [x] Add batch progress logging

- [x] Task 8: Write unit tests (AC: 1-6)
  - [x] Create `apps/api/tests/test_tts_service.py`
  - [x] Test `TTSProvider` interface contracts
  - [x] Test Edge TTS provider with mocked responses
  - [x] Test TTS provider with mocked responses
  - [x] Test fallback logic (primary failure → fallback success)
  - [x] Test batch processing
  - [x] Test configuration loading
  - [x] Test voice selection by language

## Dev Notes

### Previous Story Insights (Story 10.1)
- **Pattern Used:** ABC (Abstract Base Class) interface design with `LLMProvider` as reference
- **Service Structure:** `services/{module}/` with `__init__.py`, `base.py`, `{provider}.py`, `service.py`
- **Async Patterns:** Using `httpx.AsyncClient` for HTTP calls where needed
- **Error Hierarchy:** Specific exception types inheriting from base error
- **Configuration:** Pydantic `BaseSettings` with `DCS_` prefix
- **Testing:** pytest-asyncio with mocked external APIs

[Source: Story 10.1 Implementation]

### Project Structure
New files to create under `apps/api/app/services/tts/`:
```
apps/api/app/services/tts/
├── __init__.py          # Module exports
├── base.py              # TTSProvider ABC, models, exceptions
├── edge.py              # Edge TTS provider implementation (primary)
├── azure.py             # Azure TTS provider implementation (fallback)
└── service.py           # TTSService with fallback logic
```

[Source: Pattern from apps/api/app/services/llm/]

### Service Pattern Reference
Follow existing service patterns from `apps/api/app/services/llm/`:
- ABC-based providers with dependency injection
- Async methods for I/O operations
- Proper logging with `logging.getLogger(__name__)`
- Type hints throughout
- Dataclass for request/response models

[Source: apps/api/app/services/llm/base.py, service.py]

### Configuration Pattern Reference
Follow `apps/api/app/core/config.py` Settings pattern:
- Use pydantic `BaseSettings` with `DCS_` prefix
- Add new settings as class attributes with defaults
- Environment variables map automatically (e.g., `DCS_AZURE_TTS_KEY` → `azure_tts_key`)

[Source: apps/api/app/core/config.py:54-62]

### Environment Variables (from Epic)
```bash
# TTS Providers
DCS_AZURE_TTS_KEY=xxx
DCS_AZURE_TTS_REGION=turkeycentral

# Provider Selection
DCS_TTS_PRIMARY_PROVIDER=edge
DCS_TTS_FALLBACK_PROVIDER=azure

# Voice Configuration
DCS_TTS_DEFAULT_VOICE_EN=en-US-JennyNeural
DCS_TTS_DEFAULT_VOICE_TR=tr-TR-EmelNeural

# Audio Settings
DCS_TTS_AUDIO_FORMAT=mp3
DCS_TTS_TIMEOUT_SECONDS=30
DCS_TTS_MAX_RETRIES=3
DCS_TTS_BATCH_CONCURRENCY=5
```

[Source: docs/prd/epic-10-ai-book-processing-pipeline.md#environment-variables]

### TTS Provider Details

**Edge TTS (Primary - Free):**
- Library: `edge-tts` Python package
- No API key required (uses Microsoft Edge's TTS service)
- Async native support
- Voices: https://github.com/rany2/edge-tts (full list)
- Output: MP3 audio bytes
- Note: Rate limits may apply for heavy usage

**Azure TTS (Fallback):**
- Library: `azure-cognitiveservices-speech` or REST API
- Requires: API key + region
- High quality, production-ready
- Voices: Same voice names as Edge in many cases
- Cost: ~$4 per 1M characters

[Source: docs/prd/epic-10-ai-book-processing-pipeline.md#story-102]

### Voice Mapping (from Epic)
```python
# Default voice mapping per language
VOICE_MAPPING = {
    "en": {
        "edge": "en-US-JennyNeural",
        "azure": "en-US-JennyNeural",
        "alternatives": ["en-GB-SoniaNeural", "en-US-GuyNeural"]
    },
    "tr": {
        "edge": "tr-TR-EmelNeural",
        "azure": "tr-TR-EmelNeural",
        "alternatives": ["tr-TR-AhmetNeural"]
    }
}
```

[Source: docs/prd/epic-10-ai-book-processing-pipeline.md#story-108]

### Data Models (to implement)
```python
from dataclasses import dataclass
from enum import Enum

class TTSProviderType(str, Enum):
    EDGE = "edge"
    AZURE = "azure"

@dataclass
class TTSVoice:
    voice_id: str           # e.g., "en-US-JennyNeural"
    language: str           # e.g., "en"
    provider: str           # e.g., "edge" or "azure"

@dataclass
class TTSRequest:
    text: str
    voice: str | None = None        # If None, use default for language
    language: str = "en"
    audio_format: str = "mp3"
    speed: float = 1.0              # Speech rate multiplier

@dataclass
class TTSResponse:
    audio_data: bytes               # Raw audio bytes
    duration_ms: int | None = None  # Audio duration if available
    voice_used: str = ""
    provider: str = ""
    character_count: int = 0

@dataclass
class TTSBatchResult:
    results: list[TTSResponse | None]  # None for failed items
    errors: list[tuple[int, str]]       # (index, error_message) for failures
    success_count: int
    failure_count: int
```

### Error Hierarchy
```python
class TTSProviderError(Exception):
    """Base exception for TTS provider errors."""
    def __init__(self, message: str, provider: str, details: dict | None = None):
        self.message = message
        self.provider = provider
        self.details = details or {}
        super().__init__(f"[{provider}] {message}")

class TTSRateLimitError(TTSProviderError):
    """Raised when provider rate limit is exceeded."""
    pass

class TTSAuthError(TTSProviderError):
    """Raised when provider authentication fails."""
    pass

class TTSConnectionError(TTSProviderError):
    """Raised when connection to provider fails."""
    pass
```

[Source: Pattern from apps/api/app/services/llm/base.py:23-69]

## Testing

### Test Location
`apps/api/tests/test_tts_service.py`

### Testing Standards
- Use pytest with async support (`pytest-asyncio`)
- Mock external API/library calls (never call real TTS services in tests)
- Use `unittest.mock` or `pytest-mock` for mocking
- Test both success and failure paths
- Test fallback behavior explicitly
- Follow patterns from `apps/api/tests/test_llm_service.py`

[Source: docs/architecture/16-testing-strategy.md, apps/api/tests/test_llm_service.py]

### Test Cases to Cover
1. TTSProvider interface contract tests
2. Edge TTS synthesize (mocked)
3. Azure TTS synthesize (mocked)
4. Fallback: primary fails → fallback succeeds
5. Fallback: both providers fail → raises exception
6. Configuration loading and validation
7. Voice selection by language
8. Batch processing with partial failures
9. Batch concurrency limits

### Mock Strategy
```python
# Example mock for edge-tts
@pytest.fixture
def mock_edge_communicate():
    with patch("edge_tts.Communicate") as mock:
        mock_instance = AsyncMock()
        mock_instance.stream.return_value = [
            {"type": "audio", "data": b"fake_audio_data"}
        ]
        mock.return_value = mock_instance
        yield mock
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-30 | 0.1 | Initial story draft | Bob (SM Agent) |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References
None - implementation proceeded without blocking issues.

### Completion Notes List
- Implemented TTS provider abstraction following the exact patterns from Story 10.1 (LLM abstraction)
- Created TTSProvider ABC with synthesize() and synthesize_batch() methods
- Implemented EdgeTTSProvider using the `edge-tts` package (free, no API key)
- Implemented AzureTTSProvider using REST API with httpx (requires API key)
- Added TTS configuration settings to config.py with DCS_ prefix
- Implemented TTSService with automatic fallback (Edge → Azure) and retry logic
- Voice mapping for English (en-US-JennyNeural) and Turkish (tr-TR-EmelNeural)
- Batch processing with configurable concurrency and partial failure handling
- 36 unit tests covering all acceptance criteria, all passing
- Pre-existing test failures in other modules (auth, storage) are unrelated to this story

### File List
**Created:**
- `apps/api/app/services/tts/__init__.py` - Module exports
- `apps/api/app/services/tts/base.py` - TTSProvider ABC, models, exceptions, voice mapping
- `apps/api/app/services/tts/edge.py` - Edge TTS provider implementation
- `apps/api/app/services/tts/azure.py` - Azure TTS provider implementation
- `apps/api/app/services/tts/service.py` - TTSService with fallback logic
- `apps/api/tests/test_tts_service.py` - 36 unit tests

**Modified:**
- `apps/api/app/core/config.py` - Added TTS configuration settings
- `apps/api/pyproject.toml` - Added edge-tts and httpx dependencies

## QA Results

### Review Date: 2024-12-30

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: EXCELLENT** - Implementation follows the established patterns from Story 10.1 (LLM abstraction) precisely. Clean ABC design, proper error hierarchy, comprehensive async implementation with concurrency control, and thorough documentation.

**Strengths:**
- Clean ABC pattern with `TTSProvider` base class
- Proper exception hierarchy (`TTSProviderError` → specialized errors)
- Excellent async implementation with semaphore-based concurrency control
- Comprehensive docstrings and type hints throughout
- SSML character escaping prevents XML injection (security)
- Configurable retry with exponential backoff
- Voice mapping for multiple languages

**Minor Observations (Not Blocking):**
- `max_retries` stored in providers but retry logic handled by service layer (acceptable pattern)
- `_token` in `AzureTTSProvider` defined but token caching not implemented (future optimization opportunity)
- Singleton `get_tts_service()` uses global state (consistent with LLM service pattern)

### Refactoring Performed

No refactoring required - code quality is excellent.

### Compliance Check

- Coding Standards: ✓ Follows Python best practices, type hints, docstrings
- Project Structure: ✓ Matches `services/llm/` pattern exactly
- Testing Strategy: ✓ pytest-asyncio with proper mocking
- All ACs Met: ✓ All 6 acceptance criteria fully implemented

### Requirements Traceability (AC → Tests)

| AC | Description | Test Coverage | Status |
|----|-------------|---------------|--------|
| AC1 | Abstract interface | `TestTTSVoice`, `TTSProvider` ABC tests | ✓ |
| AC2 | Edge TTS provider | `TestEdgeTTSProvider` (6 tests) | ✓ |
| AC3 | Azure TTS provider | `TestAzureTTSProvider` (5 tests) | ✓ |
| AC4 | Multi-language voice selection | `TestVoiceMapping` (4 tests) | ✓ |
| AC5 | Batch processing | `test_batch_processing`, `test_batch_partial_failure` | ✓ |
| AC6 | Audio format configuration | Config integration in `TTSRequest` | ✓ |

### Improvements Checklist

- [x] All acceptance criteria implemented
- [x] Comprehensive test coverage (36 tests)
- [x] Proper error handling with specific exceptions
- [x] SSML escaping for security
- [x] Configurable retry with exponential backoff
- [x] Batch processing with concurrency control
- [ ] Consider token caching in Azure provider (future optimization)
- [ ] Consider adding integration test with real Edge TTS (optional)

### Security Review

**Status: PASS**
- SSML character escaping prevents XML injection attacks
- API keys not logged in any output
- No hardcoded secrets - all configuration via environment variables
- Proper authentication error handling

### Performance Considerations

**Status: PASS**
- Concurrent batch processing with configurable semaphore limits
- Exponential backoff prevents thundering herd on rate limits
- Proper async patterns throughout
- Lazy provider initialization

### Test Architecture Assessment

**Test Count:** 36 tests
**Coverage Areas:**
- Base models (7 tests)
- Voice mapping (4 tests)
- Edge TTS provider (6 tests)
- Azure TTS provider (5 tests)
- TTS Service with fallback (10 tests)
- Exception types (4 tests)

**Test Quality:** HIGH
- Proper use of fixtures and mocking
- Both success and failure paths tested
- Fallback logic explicitly tested
- Batch partial failure scenarios covered

### Files Modified During Review

None - no refactoring performed.

### Gate Status

**Gate: PASS** → `docs/qa/gates/10.2-tts-provider-abstraction-layer.yml`

**Quality Score: 100/100**

### Recommended Status

**✓ Ready for Done**

Implementation is solid, well-tested, follows established patterns, and meets all acceptance criteria. No blocking issues identified.
