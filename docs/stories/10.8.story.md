# Story 10.8: Vocabulary Audio Generation

## Status
Done

## Story
**As a** system developer,
**I want** an audio generation service that creates MP3 pronunciations for all vocabulary words,
**so that** the AI processing pipeline can provide audio files for Dream LMS to play vocabulary pronunciations in multiple languages.

## Acceptance Criteria
1. Generate MP3 for each vocabulary word
2. Support multiple languages (word + translation)
3. Appropriate voice selection per language
4. Store in `/ai-data/audio/vocabulary/{lang}/`
5. Update vocabulary.json with audio paths
6. Batch processing for efficiency
7. Handle TTS failures gracefully

## Tasks / Subtasks

- [x] Task 1: Create audio generation service module structure (AC: 1-7)
  - [x] Create `apps/api/app/services/audio_generation/__init__.py` module
  - [x] Create `apps/api/app/services/audio_generation/models.py` with dataclasses
  - [x] Define `AudioFile` dataclass: word_id, word, language, file_path, duration_ms, generated_at
  - [x] Define `WordAudioResult` dataclass: word_id, word, language, success, audio_file, error_message
  - [x] Define `BookAudioResult` dataclass: book_id, publisher_id, book_name, total_words, generated_count, failed_count, word_results, audio_files, generated_at
  - [x] Define exceptions: `AudioGenerationError`, `TTSError`, `StorageError`, `NoVocabularyFoundError`

- [x] Task 2: Create audio generation service (AC: 1-3, 6-7)
  - [x] Create `apps/api/app/services/audio_generation/service.py`
  - [x] Implement `AudioGenerationService` class
  - [x] Implement `generate_word_audio()` - generate audio for single word using TTSService
  - [x] Implement `generate_vocabulary_audio()` - generate audio for all vocabulary words
  - [x] Implement `get_audio_generation_service()` singleton factory
  - [x] Use `TTSService` from Story 10.2 with batch processing
  - [x] Select appropriate voice per language using `VOICE_MAPPING` from base.py
  - [x] Handle TTS failures gracefully with retry and fallback

- [x] Task 3: Implement audio storage (AC: 4-5)
  - [x] Create `apps/api/app/services/audio_generation/storage.py`
  - [x] Implement `AudioStorage` class
  - [x] Implement `save_audio_file()` - save single MP3 to MinIO at `ai-data/audio/vocabulary/{lang}/{word_id}.mp3`
  - [x] Implement `save_all_audio()` - save all generated audio files
  - [x] Implement `load_vocabulary()` - load vocabulary.json to get words
  - [x] Implement `update_vocabulary_audio_paths()` - update vocabulary.json with audio paths
  - [x] Implement `cleanup_audio_directory()` - clean up existing audio before re-generation
  - [x] Implement `get_audio_storage()` singleton factory

- [x] Task 4: Add audio generation configuration settings (AC: 6)
  - [x] Add settings to `apps/api/app/core/config.py`
  - [x] Add `DCS_AUDIO_GENERATION_CONCURRENCY` (default: 5, for batch TTS calls)
  - [x] Add `DCS_AUDIO_GENERATION_LANGUAGES` (default: "en,tr")
  - [x] Add `DCS_AUDIO_RETRY_FAILED` (default: true)

- [x] Task 5: Write unit tests (AC: 1-7)
  - [x] Create `apps/api/tests/test_audio_generation.py`
  - [x] Test audio generation for single word
  - [x] Test audio generation for multiple languages (en + tr)
  - [x] Test voice selection per language
  - [x] Test audio file storage in correct path
  - [x] Test vocabulary.json update with audio paths
  - [x] Test batch processing efficiency
  - [x] Test TTS failure handling and retry
  - [x] Test graceful handling of partial failures
  - [x] Mock TTSService and MinIO for isolated testing

- [x] Task 6: Integration with queue system (AC: 1-7)
  - [x] Update `apps/api/app/services/queue/tasks.py`
  - [x] Implement `_run_audio_generation()` function for audio_generation stage
  - [x] Receive vocabulary_result from previous stage
  - [x] Load vocabulary.json from storage
  - [x] Generate audio for all vocabulary words (word + translation)
  - [x] Save audio files and update vocabulary.json
  - [x] Wire progress reporting from audio generation to queue progress
  - [x] Update final metadata.json with audio generation info

## Dev Notes

### Previous Story Insights (Story 10.7)
- **Pattern Used:** Module structure follows `services/{module}/` pattern with `models.py`, `service.py`, `storage.py`, `__init__.py`
- **Singleton Pattern:** `get_*_service()` factory function for global instance
- **Exception Hierarchy:** Specific exceptions inherit from base error class with book_id context
- **Async Patterns:** Using async/await throughout services
- **Storage:** VocabularyStorage class pattern - loads from MinIO, updates, saves back
- **Queue Integration:** Add stage implementation in `_run_processing_stage()` function in tasks.py
- **Progress Callback:** Sync callback that tracks progress, final async report
- **Vocabulary JSON:** Located at `ai-data/vocabulary.json` with words array

[Source: Story 10.7 Dev Agent Record]

### TTS Service (from Story 10.2)

The `TTSService` is already implemented and provides:

```python
from app.services.tts import get_tts_service, TTSBatchItem, TTSRequest

tts_service = get_tts_service()

# Simple text-to-speech
response = await tts_service.synthesize_text(
    text="hello",
    language="en",
    voice=None,  # Uses default voice for language
    speed=1.0,
    use_fallback=True,
)
# response.audio_data contains bytes

# Batch processing with concurrency control
items = [
    TTSBatchItem(text="hello", language="en", id="hello"),
    TTSBatchItem(text="merhaba", language="tr", id="merhaba"),
]
batch_result = await tts_service.synthesize_batch(
    items=items,
    concurrency=5,  # Default from settings.tts_batch_concurrency
    use_fallback=True,
)
# batch_result.results[i] is TTSResponse or None if failed
# batch_result.errors is list of (index, error_message)
```

[Source: apps/api/app/services/tts/service.py:225-308]

### Voice Mapping (from Story 10.2)

Voice selection is handled by `VOICE_MAPPING` in `base.py`:

```python
VOICE_MAPPING = {
    "en": {
        "edge": "en-US-JennyNeural",
        "azure": "en-US-JennyNeural",
    },
    "tr": {
        "edge": "tr-TR-EmelNeural",
        "azure": "tr-TR-EmelNeural",
    },
}

# Use get_default_voice(language, provider) to get voice ID
```

Alternative voices available:
- English: `en-GB-SoniaNeural`, `en-US-GuyNeural`
- Turkish: `tr-TR-AhmetNeural`

[Source: apps/api/app/services/tts/base.py:23-38]

### TTS Configuration Settings

```python
# Already in config.py
tts_primary_provider: str = "edge"      # Free, no API key needed
tts_fallback_provider: str = "azure"    # Requires DCS_AZURE_TTS_KEY
tts_audio_format: str = "mp3"
tts_timeout_seconds: int = 30
tts_max_retries: int = 3
tts_batch_concurrency: int = 5
```

[Source: apps/api/app/core/config.py:64-74]

### Vocabulary JSON Structure (input)

Audio generation reads vocabulary from `ai-data/vocabulary.json`:
```json
{
  "language": "en",
  "translation_language": "tr",
  "total_words": 150,
  "words": [
    {
      "id": "beautiful",
      "word": "beautiful",
      "translation": "guzel",
      "definition": "pleasing to the senses...",
      "part_of_speech": "adjective",
      "level": "A2",
      "example": "It's a beautiful day.",
      "module_id": 3,
      "page": 24,
      "audio": {}  // THIS STORY POPULATES
    }
  ]
}
```

After audio generation, each word's `audio` field is populated:
```json
{
  "audio": {
    "word": "audio/vocabulary/en/beautiful.mp3",
    "translation": "audio/vocabulary/tr/guzel.mp3"
  }
}
```

[Source: docs/prd/epic-10-ai-book-processing-pipeline.md#data-schemas]

### Storage Structure

```
/publishers/{publisher_id}/books/{book_id}/{book_name}/
└── ai-data/
    ├── vocabulary.json          # UPDATED by this story (audio paths)
    └── audio/                   # CREATED by this story
        └── vocabulary/
            ├── en/              # English pronunciations
            │   ├── beautiful.mp3
            │   ├── hello.mp3
            │   └── ...
            └── tr/              # Turkish pronunciations
                ├── guzel.mp3
                ├── merhaba.mp3
                └── ...
```

[Source: docs/prd/epic-10-ai-book-processing-pipeline.md#storage-structure]

### Queue Stage Integration

The audio_generation stage has 25% weight in the processing pipeline (highest weight):
```python
PROCESSING_STAGES = {
    "text_extraction": 20,  # Story 10.4 ✓
    "segmentation": 15,     # Story 10.5 ✓
    "topic_analysis": 20,   # Story 10.6 ✓
    "vocabulary": 20,       # Story 10.7 ✓
    "audio_generation": 25, # THIS STORY
}
```

The task receives vocabulary result from previous stage:
```python
async def _run_audio_generation(
    job_id: str,
    book_id: str,
    publisher_id: str,
    book_name: str,
    progress: ProgressReporter,
    vocabulary_result: dict[str, Any] | None = None,
) -> dict[str, Any]:
```

[Source: apps/api/app/services/queue/models.py:74-80]

### Existing Dependencies

- `TTSService` from Story 10.2 (for audio synthesis)
- `VocabularyStorage` from Story 10.7 (for loading vocabulary.json)
- `QueueService` from Story 10.3 (for job integration)
- MinIO service for storage operations

[Source: apps/api/app/services/tts/, vocabulary_extraction/, queue/]

### Project File Structure

New files to create:
```
apps/api/app/services/audio_generation/
├── __init__.py              # Module exports
├── models.py                # AudioFile, WordAudioResult, BookAudioResult, exceptions
├── service.py               # AudioGenerationService
└── storage.py               # AudioStorage for MP3 files
```

[Source: Pattern from apps/api/app/services/vocabulary_extraction/]

### Audio File Naming Convention

Audio files should be named using the vocabulary word ID (slugified word):
- Word file: `{word_id}.mp3` (e.g., `beautiful.mp3`)
- Path: `ai-data/audio/vocabulary/{lang}/{word_id}.mp3`
- The word ID is already slugified in VocabularyWord.id

[Source: apps/api/app/services/vocabulary_extraction/models.py:117-127]

## Testing

### Test Location
`apps/api/tests/test_audio_generation.py`

### Testing Standards
- Use pytest with async support (`pytest-asyncio`)
- Mock MinIO storage operations
- Mock TTSService calls for audio generation tests
- Use sample vocabulary fixtures
- Follow patterns from `apps/api/tests/test_vocabulary_extraction.py`

[Source: docs/architecture/16-testing-strategy.md]

### Test Cases to Cover
1. Single word audio generation (English)
2. Single word audio generation (Turkish translation)
3. Multiple language support in batch
4. Voice selection per language
5. Audio file storage in correct path structure
6. Vocabulary.json update with audio paths
7. Batch processing with concurrency control
8. TTS provider failure and fallback
9. Partial failure handling (some words fail)
10. Empty vocabulary handling
11. Progress reporting during generation
12. Re-generation cleanup of existing audio
13. Audio path format validation

## Dependencies

### Python Packages
No new packages required - uses existing:
- `minio` (for storage)
- TTSService uses `edge-tts` and `httpx`

### Existing Services Used
- `TTSService` from Story 10.2
- `VocabularyStorage` from Story 10.7 (for loading vocabulary)
- `QueueService` from Story 10.3

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-30 | 0.1 | Initial story draft | Bob (SM Agent) |
| 2024-12-30 | 1.0 | Implementation complete | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References
N/A - No debug logs needed for this implementation

### Completion Notes List
- All 6 tasks completed successfully
- 34 unit tests added covering all acceptance criteria
- Audio generation service integrates with existing TTSService from Story 10.2
- Storage follows established patterns from VocabularyStorage (Story 10.7)
- Queue integration follows pattern from vocabulary extraction stage
- Pre-existing test failures (8 failed, 15 errors) unrelated to this story - database schema JSONB issues

### File List
**Created:**
- `apps/api/app/services/audio_generation/__init__.py` - Module exports
- `apps/api/app/services/audio_generation/models.py` - AudioFile, WordAudioResult, BookAudioResult, exceptions
- `apps/api/app/services/audio_generation/service.py` - AudioGenerationService with TTS integration
- `apps/api/app/services/audio_generation/storage.py` - AudioStorage for MP3 files and vocabulary.json updates
- `apps/api/tests/test_audio_generation.py` - 34 unit tests

**Modified:**
- `apps/api/app/core/config.py` - Added audio_generation_concurrency, audio_generation_languages, audio_retry_failed settings
- `apps/api/app/services/queue/tasks.py` - Added _run_audio_generation() function and audio_generation stage handling

## QA Results

### Review Date: 2024-12-30

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: GOOD** - The implementation follows established patterns from previous Epic 10 stories. Code is clean, well-documented, and properly structured. Minor code duplication identified but non-blocking.

**Strengths:**
- Clean module structure following `services/{module}/` pattern
- Excellent exception hierarchy with book_id context for debugging
- Proper use of dataclasses with `to_dict()`/`from_dict()` serialization
- Good dependency injection allowing service override for testing
- Comprehensive logging at appropriate levels
- Async/await used consistently throughout

**Areas for Improvement:**
- `_slugify()` method duplicated in service.py:281 and storage.py:401

### Refactoring Performed

None - Issues identified are minor and do not warrant blocking refactoring.

### Compliance Check

- Coding Standards: ✓ Follows project patterns, proper type hints, good docstrings
- Project Structure: ✓ Module structure matches vocabulary_extraction pattern
- Testing Strategy: ✓ Unit tests with mocking, pytest-asyncio used correctly
- All ACs Met: ✓ All 7 acceptance criteria have implementing code and tests

### Requirements Traceability

| AC | Test Coverage | Status |
|----|--------------|--------|
| 1. Generate MP3 for each word | `test_generate_word_audio_success`, `test_generate_vocabulary_audio_success` | ✓ |
| 2. Support multiple languages | `test_generate_vocabulary_audio_success` (en+tr), `test_generate_vocabulary_audio_without_translation` | ✓ |
| 3. Voice selection per language | Delegated to TTSService via VOICE_MAPPING | ✓ |
| 4. Store in `/ai-data/audio/vocabulary/{lang}/` | `test_build_audio_path`, `test_save_audio_file` | ✓ |
| 5. Update vocabulary.json | `test_update_vocabulary_audio_paths` | ✓ |
| 6. Batch processing | `test_generate_vocabulary_audio_success` uses `synthesize_batch` | ✓ |
| 7. Handle TTS failures | `test_generate_word_audio_failure`, `test_generate_vocabulary_audio_partial_failure` | ✓ |

### Improvements Checklist

- [x] Module structure created correctly
- [x] All dataclasses have serialization methods
- [x] Exception hierarchy follows pattern
- [x] Tests mock external services (TTS, MinIO)
- [x] Queue integration implemented
- [ ] Consider extracting `_slugify()` to shared utility module (nice-to-have)
- [ ] Add integration test for `_run_audio_generation` queue task (future story)

### Security Review

**Status: PASS** - No security concerns identified.
- Service is internal (no user input handling)
- Audio files are system-generated, not user-uploaded
- No authentication/authorization changes
- Storage paths properly constructed (no path injection risk)

### Performance Considerations

**Status: PASS** - Performance adequately addressed.
- Batch processing uses configurable concurrency (default: 5)
- Cleanup before re-generation prevents orphaned files
- TTS service handles retries internally
- No identified bottlenecks for expected vocabulary sizes

### Files Modified During Review

None - No files were modified during this review.

### Gate Status

Gate: **CONCERNS** → `docs/qa/gates/10.8-vocabulary-audio-generation.yml`

### Recommended Status

✓ **Ready for Done** - All acceptance criteria met, tests passing, minor issues documented for future consideration.
