# Story 10.4: PDF Text Extraction Pipeline

## Status
QA Passed ✅

## Story
**As a** system developer,
**I want** a PDF text extraction pipeline that extracts text content from uploaded book PDFs,
**so that** text can be preserved page-by-page for downstream AI processing (topic extraction, vocabulary extraction, etc.), with automatic OCR fallback for scanned documents.

## Acceptance Criteria
1. Extract text from PDF using PyPDF or similar library
2. Preserve page boundaries (one text file per page)
3. Handle multi-column layouts
4. Detect and handle scanned PDFs (no selectable text)
5. For scanned PDFs, use Gemini Vision for OCR
6. Store extracted text per page in `/ai-data/text/` directory
7. Handle extraction errors gracefully

## Tasks / Subtasks

- [x] Task 1: Create PDF extraction service module structure (AC: 1)
  - [x] Create `apps/api/app/services/pdf/__init__.py` module
  - [x] Create `apps/api/app/services/pdf/models.py` with dataclasses
  - [x] Define `PDFExtractionResult` dataclass with fields: book_id, total_pages, pages (list of PageText), extracted_at
  - [x] Define `PageText` dataclass with fields: page_number, text, method (native/ocr), word_count, char_count
  - [x] Define `ExtractionMethod` enum: NATIVE, OCR, MIXED
  - [x] Define PDF-specific exceptions: `PDFExtractionError`, `PDFNotFoundError`, `OCRError`, `PDFPasswordProtectedError`

- [x] Task 2: Implement native PDF text extraction (AC: 1, 2, 3)
  - [x] Create `apps/api/app/services/pdf/extractor.py`
  - [x] Install `pymupdf` package (add to pyproject.toml dependencies)
  - [x] Implement `PDFExtractor` class
  - [x] Implement `extract_text_from_page()` - extracts text from a single page
  - [x] Implement `extract_all_pages()` - iterates all pages and extracts text
  - [x] Handle multi-column layouts using pymupdf's text blocks with sorting by position
  - [x] Preserve page boundaries (return list of PageText objects)
  - [x] Add proper error handling for corrupted PDFs

- [x] Task 3: Implement scanned PDF detection (AC: 4)
  - [x] Create `apps/api/app/services/pdf/detector.py`
  - [x] Implement `is_scanned_page()` - detects if a page has minimal selectable text
  - [x] Define threshold: page is "scanned" if extracted text < 50 chars OR word count < 10 words
  - [x] Implement `analyze_pdf()` - analyzes entire PDF and returns scanned/native/mixed classification
  - [x] Return detailed metrics: total_pages, scanned_pages, native_pages, classification

- [x] Task 4: Implement OCR fallback using Gemini Vision (AC: 5)
  - [x] Create `apps/api/app/services/pdf/ocr.py`
  - [x] Implement `PDFOCRService` class
  - [x] Implement `page_to_image()` - converts PDF page to PNG bytes using pymupdf
  - [x] Implement `ocr_page()` - sends page image to Gemini Vision for text extraction
  - [x] Use LLMService from Story 10.1 with vision capability
  - [x] Implement OCR prompt template for text extraction
  - [x] Handle rate limiting with exponential backoff
  - [x] Add progress callback for long OCR operations

- [x] Task 5: Add PDF extraction configuration settings (AC: 1, 4, 5)
  - [x] Add PDF extraction settings to `apps/api/app/core/config.py`
  - [x] Add `DCS_PDF_MIN_TEXT_THRESHOLD` setting (default: 50 chars)
  - [x] Add `DCS_PDF_MIN_WORD_THRESHOLD` setting (default: 10 words)
  - [x] Add `DCS_PDF_OCR_ENABLED` setting (default: true)
  - [x] Add `DCS_PDF_OCR_BATCH_SIZE` setting (default: 5 pages)
  - [x] Add `DCS_PDF_OCR_DPI` setting (default: 150)
  - [x] Add `DCS_PDF_MAX_PAGES` setting (default: 500)

- [x] Task 6: Implement unified PDF extraction service (AC: 1-7)
  - [x] Create `apps/api/app/services/pdf/service.py`
  - [x] Implement `PDFExtractionService` class
  - [x] Implement `extract_book_pdf()` - main entry point, coordinates extraction
  - [x] Accept parameters: book_id, publisher_id, book_name (to construct storage paths)
  - [x] Logic: Try native extraction first, detect scanned pages, OCR fallback as needed
  - [x] Implement progress reporting callback for queue integration
  - [x] Implement `get_extraction_service()` singleton factory function
  - [x] Handle PDF download from MinIO: `/{publisher_id}/books/{book_id}/{book_name}/raw/original.pdf`
  - [x] Handle password-protected PDF detection and error

- [x] Task 7: Implement text storage to ai-data structure (AC: 6)
  - [x] Create `apps/api/app/services/pdf/storage.py`
  - [x] Implement `AIDataStorage` class
  - [x] Implement `save_extracted_text()` - saves text files to MinIO
  - [x] Storage path pattern: `/{publisher_id}/books/{book_id}/{book_name}/ai-data/text/page_{NNN}.txt`
  - [x] PDF source path: `/{publisher_id}/books/{book_id}/{book_name}/raw/original.pdf`
  - [x] Implement `save_extraction_metadata()` - saves extraction_metadata.json with extraction info
  - [x] Implement atomic writes (write to temp location, then move)
  - [x] Implement cleanup method for re-extraction (delete existing ai-data/text/)

- [x] Task 8: Write unit tests (AC: 1-7)
  - [x] Create `apps/api/tests/test_pdf_extraction.py`
  - [x] Test native text extraction from text-based PDF
  - [x] Test page boundary preservation
  - [x] Test scanned page detection (mock minimal text response)
  - [x] Test OCR fallback trigger when scanned detected
  - [x] Test multi-column layout handling
  - [x] Test extraction error handling (corrupted PDF)
  - [x] Test password-protected PDF detection
  - [x] Test text storage to MinIO
  - [x] Test progress callback invocation
  - [x] Mock Gemini Vision calls for OCR tests

- [x] Task 9: Integration with queue system (AC: 1-7)
  - [x] Update `apps/api/app/services/queue/tasks.py`
  - [x] Add `TEXT_EXTRACTION` stage to processing stages
  - [x] Implement text extraction step in `process_book_task()`
  - [x] Wire progress reporting from extraction to queue progress
  - [x] Handle extraction failures with proper job status updates

## Dev Notes

### Previous Story Insights (Stories 10.1, 10.2, 10.3)
- **Pattern Used:** ABC (Abstract Base Class) interface design for providers
- **Service Structure:** `services/{module}/` with `__init__.py`, `models.py`, `service.py` pattern
- **Async Patterns:** Using `httpx.AsyncClient` for HTTP calls, async/await throughout
- **Error Hierarchy:** Specific exception types inheriting from base error
- **Configuration:** Pydantic `BaseSettings` with `DCS_` prefix, settings in `config.py`
- **Testing:** pytest-asyncio with mocked external dependencies
- **Singleton Pattern:** `get_service()` function for global service instance
- **Queue Integration:** Tasks defined in `queue/tasks.py`, progress via `ProgressReporter`

[Source: Story 10.1-10.3 Implementation]

### Project Structure
New files to create under `apps/api/app/services/pdf/`:
```
apps/api/app/services/pdf/
├── __init__.py          # Module exports
├── models.py            # PDFExtractionResult, PageText, ExtractionMethod, exceptions
├── extractor.py         # Native PDF text extraction using pymupdf
├── detector.py          # Scanned PDF detection
├── ocr.py               # Gemini Vision OCR integration
├── storage.py           # AI data storage (save text files to MinIO)
└── service.py           # PDFExtractionService (main entry point)
```

[Source: Pattern from apps/api/app/services/llm/, tts/, queue/]

### PDF Library Selection

**pymupdf (PyMuPDF/fitz) - RECOMMENDED:**
- High-performance PDF parsing
- Excellent text extraction with position info (handles multi-column)
- Built-in page-to-image conversion (needed for OCR)
- Active maintenance, extensive documentation
- Library: `pymupdf>=1.24.0,<2.0`

**Why not pypdf:**
- Slower text extraction
- Less accurate with complex layouts
- No built-in image rendering

**Why not pdfplumber:**
- Slower for large documents
- More complex API for simple extraction

[Source: Epic 10.4 technical notes, project async patterns]

### Configuration Pattern Reference
Follow `apps/api/app/core/config.py` Settings pattern:
```python
# PDF Extraction Configuration
pdf_min_text_threshold: int = 50  # chars below this = scanned
pdf_min_word_threshold: int = 10  # words below this = scanned
pdf_ocr_enabled: bool = True
pdf_ocr_batch_size: int = 5  # pages per OCR batch
pdf_ocr_dpi: int = 150  # resolution for page images
pdf_max_pages: int = 500  # max pages per book
```

[Source: apps/api/app/core/config.py:54-91]

### Data Models (to implement)
```python
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum

class ExtractionMethod(str, Enum):
    NATIVE = "native"      # Text extracted directly from PDF
    OCR = "ocr"            # Text extracted via Gemini Vision
    MIXED = "mixed"        # Some pages native, some OCR

@dataclass
class PageText:
    page_number: int
    text: str
    method: ExtractionMethod
    word_count: int = field(init=False)
    char_count: int = field(init=False)

    def __post_init__(self) -> None:
        self.char_count = len(self.text)
        self.word_count = len(self.text.split())

@dataclass
class PDFExtractionResult:
    book_id: str
    publisher_id: str
    book_name: str  # Needed for storage path construction
    total_pages: int
    pages: list[PageText]
    method: ExtractionMethod  # Overall classification
    scanned_page_count: int
    native_page_count: int
    total_word_count: int = field(init=False)
    extracted_at: datetime = field(default_factory=datetime.utcnow)

    def __post_init__(self) -> None:
        self.total_word_count = sum(p.word_count for p in self.pages)
```

### Error Hierarchy
```python
class PDFExtractionError(Exception):
    """Base exception for PDF extraction errors."""
    def __init__(self, message: str, book_id: str, details: dict | None = None):
        self.message = message
        self.book_id = book_id
        self.details = details or {}
        super().__init__(message)

class PDFNotFoundError(PDFExtractionError):
    """Raised when PDF file is not found in storage."""
    def __init__(self, book_id: str, path: str):
        super().__init__(f"PDF not found: {path}", book_id, {"path": path})

class PDFPasswordProtectedError(PDFExtractionError):
    """Raised when PDF is password protected."""
    def __init__(self, book_id: str):
        super().__init__("PDF is password protected", book_id)

class OCRError(PDFExtractionError):
    """Raised when OCR processing fails."""
    def __init__(self, book_id: str, page: int, reason: str):
        super().__init__(f"OCR failed for page {page}: {reason}", book_id, {"page": page})
```

[Source: Pattern from apps/api/app/services/llm/base.py:23-69, queue/models.py]

### Multi-Column Layout Handling
pymupdf provides text blocks with position info. Strategy:
```python
def extract_text_sorted(page) -> str:
    """Extract text with proper reading order for multi-column layouts."""
    blocks = page.get_text("dict")["blocks"]

    # Sort blocks by vertical position first, then horizontal
    # This handles multi-column by reading top-to-bottom, left-to-right
    text_blocks = [b for b in blocks if b["type"] == 0]  # type 0 = text

    sorted_blocks = sorted(text_blocks, key=lambda b: (b["bbox"][1], b["bbox"][0]))

    text_parts = []
    for block in sorted_blocks:
        for line in block.get("lines", []):
            line_text = " ".join(span["text"] for span in line.get("spans", []))
            text_parts.append(line_text)

    return "\n".join(text_parts)
```

### OCR Prompt Template
```python
OCR_PROMPT = """Extract all text from this book page image.

Instructions:
- Extract ALL visible text including headers, body text, captions, and footnotes
- Preserve paragraph structure with blank lines between paragraphs
- Maintain reading order (left-to-right, top-to-bottom)
- Do NOT describe the image or add commentary
- If text is unclear, make best effort to transcribe

Return ONLY the extracted text, nothing else."""
```

### Gemini Vision Integration
Uses LLMService from Story 10.1:
```python
from app.services.llm import get_llm_service, LLMProviderType

async def ocr_page(page_image: bytes) -> str:
    """OCR a page using Gemini Vision."""
    llm = get_llm_service()
    response = await llm.complete_with_vision(
        prompt=OCR_PROMPT,
        images=[page_image],
        provider=LLMProviderType.GEMINI  # Only Gemini has vision
    )
    return response.content
```

[Source: apps/api/app/services/llm/gemini.py, Epic 10.4 notes]

### Book Folder Structure
Books are stored in MinIO with this structure:
```
/publishers/{publisher_id}/books/{book_id}/{book_name}/
├── audio/                    # Audio files
├── video/                    # Video files
├── images/                   # Image files
├── config.json               # Book configuration
├── raw/                      # Source PDF files
│   ├── original.pdf          # ← PDF to process
│   └── answered.pdf          # Answer key (not processed)
└── ai-data/                  # AI-generated content (created by pipeline)
    └── text/
        ├── page_001.txt
        ├── page_002.txt
        ├── ...
        └── extraction_metadata.json
```

**PDF Source Path:** `/publishers/{publisher_id}/books/{book_id}/{book_name}/raw/original.pdf`
**Output Path:** `/publishers/{publisher_id}/books/{book_id}/{book_name}/ai-data/text/`

metadata.json includes:
```json
{
  "extraction_method": "mixed",
  "total_pages": 120,
  "scanned_pages": 15,
  "native_pages": 105,
  "total_word_count": 45000,
  "extracted_at": "2024-01-15T10:30:00Z"
}
```

[Source: docs/prd/epic-10-ai-book-processing-pipeline.md#storage-structure]

### Queue Integration
Update `queue/tasks.py` to call extraction service:
```python
# In process_book_task()
async def _run_text_extraction(job: ProcessingJob, reporter: ProgressReporter) -> PDFExtractionResult:
    """Run text extraction stage."""
    extraction_service = get_extraction_service()

    def on_progress(current: int, total: int):
        stage_progress = int((current / total) * 100)
        reporter.report_step_progress("text_extraction", stage_progress)

    # book_name should be stored in job.metadata or fetched from book record
    book_name = job.metadata.get("book_name")

    result = await extraction_service.extract_book_pdf(
        book_id=job.book_id,
        publisher_id=job.publisher_id,
        book_name=book_name,
        progress_callback=on_progress
    )

    return result
```

**Note:** The `book_name` is required to construct the correct MinIO path. It should be included in `job.metadata` when the processing job is created (Story 10.10 will handle this).

[Source: apps/api/app/services/queue/tasks.py, queue/service.py]

## Testing

### Test Location
`apps/api/tests/test_pdf_extraction.py`

### Testing Standards
- Use pytest with async support (`pytest-asyncio`)
- Mock MinIO storage operations
- Mock Gemini Vision calls for OCR tests
- Use sample PDF fixtures (text-based and image-based)
- Follow patterns from `apps/api/tests/test_llm_service.py`, `test_tts_service.py`

[Source: docs/architecture/16-testing-strategy.md]

### Test Cases to Cover
1. Native text extraction from text-based PDF
2. Page boundary preservation (correct page count and mapping)
3. Multi-column layout extraction (text in correct order)
4. Scanned page detection (minimal text triggers scanned flag)
5. OCR fallback when scanned pages detected
6. Extraction error handling (corrupted PDF returns error)
7. Password-protected PDF detection
8. Text file storage to MinIO (correct paths)
9. Progress callback invocation (called with correct values)
10. Configuration thresholds (min text, min words)
11. Max pages limit enforcement
12. Mixed mode (some native, some OCR pages)

### Mock Strategy
```python
@pytest.fixture
def sample_pdf_bytes() -> bytes:
    """Create a simple test PDF with text content."""
    import fitz  # pymupdf
    doc = fitz.open()
    page = doc.new_page()
    page.insert_text((50, 50), "Sample text content for testing.")
    return doc.tobytes()

@pytest.fixture
def mock_minio_service(mocker):
    """Mock MinIO service for storage tests."""
    mock = mocker.patch("app.services.pdf.storage.minio_service")
    mock.put_object = mocker.AsyncMock()
    mock.get_object = mocker.AsyncMock(return_value=sample_pdf_bytes)
    return mock

@pytest.fixture
def mock_llm_service(mocker):
    """Mock LLM service for OCR tests."""
    mock = mocker.patch("app.services.pdf.ocr.get_llm_service")
    mock.return_value.complete_with_vision = mocker.AsyncMock(
        return_value=LLMResponse(content="Extracted OCR text", ...)
    )
    return mock
```

## Dependencies

### New Python Packages
```toml
# Add to apps/api/pyproject.toml
dependencies = [
  # ... existing dependencies
  "pymupdf>=1.24.0,<2.0",  # PDF parsing and image rendering
]
```

### Existing Dependencies Used
- `LLMService` from Story 10.1 (for Gemini Vision OCR)
- `QueueService` from Story 10.3 (for job integration)
- MinIO service for storage operations

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References
None

### Completion Notes List
- All 9 tasks completed successfully
- 44 unit tests written and passing
- Full test suite passes with no new regressions (pre-existing failures unrelated to this story)
- PDF extraction uses pymupdf library for high-performance parsing
- OCR fallback integrates with existing LLMService (Gemini Vision)
- Storage follows ai-data structure pattern per Epic 10 spec
- Queue integration added `book_name` parameter to `process_book_task`

### File List
| File | Action | Description |
|------|--------|-------------|
| apps/api/app/services/pdf/__init__.py | Created | PDF service module exports |
| apps/api/app/services/pdf/models.py | Created | Data models and exceptions (PageText, PDFExtractionResult, etc.) |
| apps/api/app/services/pdf/extractor.py | Created | Native PDF text extraction using pymupdf |
| apps/api/app/services/pdf/detector.py | Created | Scanned PDF detection logic |
| apps/api/app/services/pdf/ocr.py | Created | Gemini Vision OCR integration |
| apps/api/app/services/pdf/service.py | Created | Unified PDFExtractionService |
| apps/api/app/services/pdf/storage.py | Created | AIDataStorage for text files |
| apps/api/app/core/config.py | Modified | Added PDF extraction configuration settings |
| apps/api/app/services/queue/tasks.py | Modified | Added text_extraction stage implementation |
| apps/api/pyproject.toml | Modified | Added pymupdf dependency |
| apps/api/tests/test_pdf_extraction.py | Created | 44 unit tests for PDF extraction |


## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-30 | 0.1 | Initial story draft | Bob (SM Agent) |
| 2024-12-30 | 1.0 | Implementation complete - all tasks done, 44 tests passing | James (Dev Agent) |
| 2024-12-30 | 1.1 | QA Review completed - PASS | Quinn (QA Agent) |

## QA Results

### Gate Decision: ✅ PASS

### Review Summary

**Reviewer:** Quinn (QA Agent)
**Date:** 2024-12-30
**Test Results:** 44/44 tests passing

### Acceptance Criteria Verification

| AC | Description | Status | Evidence |
|----|-------------|--------|----------|
| 1 | Extract text from PDF using PyPDF or similar | ✅ PASS | pymupdf used via `PDFExtractor` class. Tests: `test_extract_text_from_page`, `test_extract_all_pages` |
| 2 | Preserve page boundaries | ✅ PASS | `PageText` model with page_number. Storage: `page_{NNN}.txt`. Tests: `test_extract_all_pages`, `test_full_extraction_pipeline` |
| 3 | Handle multi-column layouts | ✅ PASS | `extractor.py:60-87` sorts text blocks by position. Test: `test_multicolumn_text_extraction` |
| 4 | Detect scanned PDFs | ✅ PASS | `ScannedPDFDetector` with 50 char/10 word thresholds. Tests: `test_detect_scanned_page_*`, `test_analyze_page_texts_*` |
| 5 | Use Gemini Vision for OCR | ✅ PASS | `PDFOCRService` integrates with `LLMService`. Tests: `test_ocr_page_success`, `test_ocr_page_retry_on_failure` |
| 6 | Store text per page in ai-data/text/ | ✅ PASS | `AIDataStorage.save_extracted_text()` saves to correct path. Tests: `test_save_extracted_text`, `test_build_text_path` |
| 7 | Handle extraction errors gracefully | ✅ PASS | Exception hierarchy: `PDFNotFoundError`, `PDFCorruptedError`, `OCRError`, etc. Tests: `test_*_error`, `test_open_corrupted_pdf` |

### Code Quality Assessment

**Architecture:** ✅ Follows established patterns from Stories 10.1-10.3
- Module structure matches `services/{module}/` pattern
- Singleton factory pattern (`get_extraction_service()`, `get_ai_storage()`)
- Proper exception hierarchy inheriting from base error
- Async patterns consistent with existing codebase

**Test Coverage:** ✅ Comprehensive
- 44 tests covering all components
- Unit tests for each class/function
- Integration tests for end-to-end pipeline
- Mocked external dependencies (MinIO, LLM service)
- Edge cases covered (empty pages, corrupted PDFs, password protection)

**Documentation:** ✅ Complete
- All functions have docstrings
- Story file fully updated with task completion
- Dev notes section provides implementation context

### Minor Observations (Non-blocking)

1. **Import placement in tasks.py:289** - `import asyncio` inside function is unconventional but acceptable for avoiding circular imports
2. **service.py** has unused import `logging` at module level (already used, so fine)

### Regression Check

- Full test suite: 342 tests pass
- Pre-existing failures unrelated to Story 10.4
- No new regressions introduced

### Files Reviewed

| File | Lines | Status |
|------|-------|--------|
| app/services/pdf/__init__.py | 44 | ✅ |
| app/services/pdf/models.py | 178 | ✅ |
| app/services/pdf/extractor.py | 208 | ✅ |
| app/services/pdf/detector.py | 106 | ✅ |
| app/services/pdf/ocr.py | 159 | ✅ |
| app/services/pdf/service.py | 204 | ✅ |
| app/services/pdf/storage.py | 346 | ✅ |
| app/core/config.py | Modified | ✅ |
| app/services/queue/tasks.py | Modified | ✅ |
| tests/test_pdf_extraction.py | 44 tests | ✅ |
