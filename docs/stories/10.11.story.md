# Story 10.11: AI Data Retrieval API

## Status
Done

## Story
**As a** Dream LMS developer or external consumer,
**I want** API endpoints to retrieve AI-processed book data,
**so that** I can access modules, vocabulary, audio files, and processing metadata for content generation and learning features.

## Acceptance Criteria
1. GET modules list for a book
2. GET single module with full data
3. GET vocabulary (full list or by module)
4. GET vocabulary audio URL
5. GET processing status and metadata
6. Proper caching headers
7. 404 if not processed yet

## Tasks / Subtasks

- [x] Task 1: Create API schemas for AI data responses (AC: 1-5)
  - [x] Create `apps/api/app/schemas/ai_data.py`
  - [x] Define `ModuleListResponse` schema for modules list
  - [x] Define `ModuleDetailResponse` schema with full module data
  - [x] Define `VocabularyResponse` schema with words array
  - [x] Define `VocabularyWordResponse` schema for single word
  - [x] Define `ProcessingMetadataResponse` schema
  - [x] Export schemas in `apps/api/app/schemas/__init__.py`

- [x] Task 2: Create AI data retrieval service (AC: 1-5, 7)
  - [x] Create `apps/api/app/services/ai_data/retrieval.py`
  - [x] Implement `get_metadata(publisher, book_id, book_name)` method
  - [x] Implement `list_modules(publisher, book_id, book_name)` method
  - [x] Implement `get_module(publisher, book_id, book_name, module_id)` method
  - [x] Implement `get_vocabulary(publisher, book_id, book_name, module_id=None)` method
  - [x] Return None when data not found (for 404 handling)
  - [x] Update `apps/api/app/services/ai_data/__init__.py` exports

- [x] Task 3: Create AI data router with metadata endpoint (AC: 5, 6, 7)
  - [x] Create `apps/api/app/routers/ai_data.py`
  - [x] Implement `GET /books/{book_id}/ai-data/metadata` endpoint
  - [x] Add authentication using HTTPBearer (same pattern as processing.py)
  - [x] Validate book exists using BookRepository
  - [x] Return 404 if no metadata.json exists
  - [x] Add Cache-Control headers (e.g., max-age=60)

- [x] Task 4: Implement modules endpoints (AC: 1, 2, 6, 7)
  - [x] Implement `GET /books/{book_id}/ai-data/modules` endpoint
  - [x] Return list of modules with module_id, title, pages, word_count
  - [x] Implement `GET /books/{book_id}/ai-data/modules/{module_id}` endpoint
  - [x] Return full module data including text and topics
  - [x] Return 404 if modules not found or module_id invalid
  - [x] Add Cache-Control headers

- [x] Task 5: Implement vocabulary endpoints (AC: 3, 6, 7)
  - [x] Implement `GET /books/{book_id}/ai-data/vocabulary` endpoint
  - [x] Support optional `?module={id}` query parameter to filter by module
  - [x] Return vocabulary with words array and metadata
  - [x] Return 404 if vocabulary.json not found
  - [x] Add Cache-Control headers

- [x] Task 6: Implement audio URL endpoint (AC: 4, 6, 7)
  - [x] Implement `GET /books/{book_id}/ai-data/audio/vocabulary/{lang}/{word}.mp3` endpoint
  - [x] Generate presigned MinIO URL for audio file
  - [x] Validate language code (en, tr, etc.)
  - [x] Return 404 if audio file not found
  - [x] Consider redirect vs proxy approach

- [x] Task 7: Register router in main.py (AC: 1-5)
  - [x] Import ai_data router in `apps/api/app/main.py`
  - [x] Add router with `app.include_router(ai_data.router)`
  - [x] Update `apps/api/app/routers/__init__.py` to export ai_data

- [x] Task 8: Write unit tests (AC: 1-7)
  - [x] Create `apps/api/tests/test_ai_data_api.py`
  - [x] Test GET metadata returns processing info
  - [x] Test GET metadata returns 404 when not processed
  - [x] Test GET modules returns list
  - [x] Test GET module/{id} returns full data
  - [x] Test GET module/{id} returns 404 for invalid id
  - [x] Test GET vocabulary returns words
  - [x] Test GET vocabulary with module filter
  - [x] Test GET audio returns presigned URL or 404
  - [x] Test authentication required on all endpoints
  - [x] Mock MinIO client for storage operations

## Dev Notes

### Previous Story Insights (Story 10.10)
- **Storage Path Convention:** Storage paths use publisher NAME (`book.publisher`), NOT publisher_id. Example: `Universal ELT/books/BRAINS/ai-data/`
- **Authentication Pattern:** Use `_require_auth()` function with HTTPBearer, returns user_id or -1 for API key auth
- **Router Registration:** Add to `main.py` via `app.include_router()` and export from `routers/__init__.py`
- **Test Limitation:** SQLite doesn't support JSONB - tests need mocking or PostgreSQL

[Source: Story 10.10 Dev Agent Record]

### Existing AI Data Services

The following storage services already exist and should be leveraged:

```python
# PDF/Text storage
from app.services.pdf.storage import AIDataStorage, get_ai_storage

ai_storage = get_ai_storage()
metadata = ai_storage.get_extraction_metadata(publisher, book_id, book_name)
```

```python
# Module storage - can load module JSON
from app.services.segmentation.storage import ModuleStorage, get_module_storage

module_storage = get_module_storage()
# Need to add retrieval methods
```

```python
# Vocabulary storage - already has load_vocabulary()
from app.services.vocabulary_extraction.storage import VocabularyStorage, get_vocabulary_storage

vocab_storage = get_vocabulary_storage()
vocab = vocab_storage.load_vocabulary(publisher, book_id, book_name)
```

```python
# Metadata service
from app.services.ai_data.service import get_ai_data_metadata_service

metadata_service = get_ai_data_metadata_service()
metadata = metadata_service.get_metadata(publisher, book_id, book_name)
```

[Source: apps/api/app/services/pdf/storage.py, apps/api/app/services/vocabulary_extraction/storage.py]

### MinIO Path Structure

AI data is stored at:
```
{publisher_name}/books/{book_name}/ai-data/
├── text/
│   ├── page_001.txt
│   ├── extraction_metadata.json
├── modules/
│   ├── module_1.json
│   ├── module_2.json
│   └── segmentation_metadata.json
├── vocabulary.json
├── vocabulary_metadata.json
├── metadata.json
└── audio/
    └── vocabulary/
        ├── en/
        │   └── {word}.mp3
        └── tr/
            └── {word}.mp3
```

[Source: docs/prd/epic-10-ai-book-processing-pipeline.md#storage-structure]

### Data Schemas (from Epic 10)

**Module JSON** (`modules/module_N.json`):
```json
{
  "module_id": 1,
  "title": "Unit 1: Greetings",
  "pages": [1, 2, 3, 4, 5],
  "text": "Full text content of the module...",
  "topics": ["greetings", "introductions", "basic phrases"],
  "vocabulary_ids": ["hello", "goodbye"],
  "language": "en",
  "difficulty": "A1",
  "word_count": 450,
  "extracted_at": "2024-01-15T10:30:00Z"
}
```

**Vocabulary JSON** (`vocabulary.json`):
```json
{
  "language": "en",
  "translation_language": "tr",
  "total_words": 150,
  "words": [
    {
      "id": "beautiful",
      "word": "beautiful",
      "translation": "guzel",
      "definition": "pleasing to the senses",
      "part_of_speech": "adjective",
      "level": "A2",
      "example": "It's a beautiful day.",
      "module_id": 3,
      "page": 24,
      "audio": {
        "word": "audio/vocabulary/en/beautiful.mp3",
        "translation": "audio/vocabulary/tr/guzel.mp3"
      }
    }
  ],
  "extracted_at": "2024-01-15T10:30:00Z"
}
```

**Metadata JSON** (`metadata.json`):
```json
{
  "book_id": "uuid",
  "processing_status": "completed",
  "processing_started_at": "2024-01-15T10:00:00Z",
  "processing_completed_at": "2024-01-15T10:35:00Z",
  "total_pages": 120,
  "total_modules": 8,
  "total_vocabulary": 150,
  "total_audio_files": 300,
  "languages": ["en", "tr"],
  "primary_language": "en",
  "difficulty_range": ["A1", "A2", "B1"],
  "errors": []
}
```

[Source: docs/prd/epic-10-ai-book-processing-pipeline.md#data-schemas]

### API Endpoints to Implement

```
GET /books/{book_id}/ai-data/metadata
GET /books/{book_id}/ai-data/modules
GET /books/{book_id}/ai-data/modules/{module_id}
GET /books/{book_id}/ai-data/vocabulary
GET /books/{book_id}/ai-data/vocabulary?module={id}
GET /books/{book_id}/ai-data/audio/vocabulary/{lang}/{word}.mp3
```

[Source: docs/prd/epic-10-ai-book-processing-pipeline.md#story-1011]

### Authentication Pattern

Follow the processing.py authentication pattern:

```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from app.core.security import decode_access_token, verify_api_key_from_db

router = APIRouter(prefix="/books", tags=["AI Data"])
_bearer_scheme = HTTPBearer(auto_error=True)

def _require_auth(credentials: HTTPAuthorizationCredentials, db: Session) -> int:
    """Validate JWT token or API key and return user ID or -1 for API key auth."""
    # Same implementation as processing.py
```

[Source: apps/api/app/routers/processing.py:42-69]

### MinIO Presigned URL for Audio

For audio files, generate presigned URLs:

```python
from app.services.minio import get_minio_client

client = get_minio_client(settings)
presigned_url = client.presigned_get_object(
    bucket_name=settings.minio_publishers_bucket,
    object_name=audio_path,
    expires=timedelta(hours=1),  # URL valid for 1 hour
)
```

[Source: MinIO Python SDK pattern]

### Cache-Control Headers

Add caching headers to improve performance:

```python
from fastapi.responses import JSONResponse

response = JSONResponse(content=data)
response.headers["Cache-Control"] = "public, max-age=60"  # Cache for 60 seconds
return response
```

### Book Repository

Use existing BookRepository to validate book exists:

```python
from app.repositories.book import BookRepository

_book_repository = BookRepository()

book = _book_repository.get_by_id(db, book_id)
if book is None:
    raise HTTPException(status_code=404, detail="Book not found")

# Get publisher name for storage path
publisher_name = book.publisher  # ORM property returns publisher name
book_name = book.book_name
```

[Source: apps/api/app/routers/processing.py:152-158]

### File Structure

New files to create:
```
apps/api/app/
├── routers/
│   └── ai_data.py           # New router for AI data retrieval
├── schemas/
│   └── ai_data.py           # New schemas for responses
├── services/
│   └── ai_data/
│       └── retrieval.py     # New retrieval service
└── tests/
    └── test_ai_data_api.py  # New tests
```

Files to modify:
```
apps/api/app/main.py              # Add router registration
apps/api/app/routers/__init__.py  # Export new router
apps/api/app/schemas/__init__.py  # Export new schemas
apps/api/app/services/ai_data/__init__.py  # Export retrieval service
```

## Testing

### Test Location
`apps/api/tests/test_ai_data_api.py`

### Testing Standards
- Use pytest with async support (`pytest-asyncio`)
- Mock MinIO client using `unittest.mock.MagicMock`
- Mock BookRepository for database operations
- Use fixtures for common test data
- Follow patterns from `apps/api/tests/test_processing_api.py`

[Source: apps/api/tests/test_processing_api.py]

### Test Cases to Cover
1. GET metadata returns processing info
2. GET metadata returns 404 when book not processed
3. GET metadata returns 404 when book not found
4. GET modules returns list with module summaries
5. GET modules returns 404 when no modules
6. GET module/{id} returns full module data
7. GET module/{id} returns 404 for invalid module_id
8. GET vocabulary returns words array
9. GET vocabulary?module=1 filters by module
10. GET vocabulary returns 404 when not processed
11. GET audio returns presigned URL
12. GET audio returns 404 for non-existent file
13. All endpoints require authentication
14. Cache-Control headers present in responses

## Dependencies

### Python Packages
No new packages required - uses existing:
- `fastapi` (for API endpoints)
- `pydantic` (for schemas)
- `minio` (for storage access and presigned URLs)

### Existing Services Used
- `BookRepository` from `app.repositories.book`
- `AIDataStorage` from `app.services.pdf.storage`
- `ModuleStorage` from `app.services.segmentation.storage`
- `VocabularyStorage` from `app.services.vocabulary_extraction.storage`
- `AIDataMetadataService` from `app.services.ai_data.service`
- `get_minio_client()` from `app.services`
- Authentication utilities from `app.core.security`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-30 | 0.1 | Initial story draft | Bob (SM Agent) |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Completion Notes List
- Implemented all 6 API endpoints for AI data retrieval (metadata, modules list, module detail, vocabulary, audio URL)
- Leveraged existing storage services (ModuleStorage, VocabularyStorage, AIDataMetadataService)
- Created unified AIDataRetrievalService to coordinate data access
- Added Cache-Control headers with appropriate TTLs (60s metadata, 300s modules/vocab, 3600s audio)
- Audio endpoint returns presigned MinIO URLs (1-hour expiry) instead of proxying files
- Added language code validation for audio (supports en, tr, de, fr, es, it, pt, ru, ar, zh, ja, ko)
- Added word format validation to prevent path traversal attacks
- All 23 unit tests pass using mocked dependencies (due to SQLite/JSONB limitation)
- Tests cover: authentication, 404 handling, successful responses, module filtering, cache headers

### File List
**New Files:**
- `apps/api/app/schemas/ai_data.py` - Pydantic schemas for API responses
- `apps/api/app/services/ai_data/retrieval.py` - AI data retrieval service
- `apps/api/app/routers/ai_data.py` - API router with all endpoints
- `apps/api/tests/test_ai_data_api.py` - Unit tests (23 tests)

**Modified Files:**
- `apps/api/app/schemas/__init__.py` - Added ai_data schema exports
- `apps/api/app/services/ai_data/__init__.py` - Added retrieval service exports
- `apps/api/app/routers/__init__.py` - Added ai_data router export
- `apps/api/app/main.py` - Registered ai_data router

## QA Results

### Review Date: 2024-12-30

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent** - Implementation is clean, well-structured, and follows established project patterns (matching `processing.py` conventions). Good separation of concerns with dedicated schemas, service layer, and router. All public methods have proper docstrings and type hints.

**Strengths:**
- Clean service abstraction via `AIDataRetrievalService` that coordinates multiple underlying storage services
- Consistent error handling with appropriate HTTP status codes (400, 401, 404)
- Well-defined Pydantic schemas with descriptive Field descriptions
- Proper use of `TYPE_CHECKING` for import optimization
- Cache-Control headers with sensible TTLs (60s metadata, 300s modules/vocab, 3600s audio)

### Refactoring Performed

None required - code quality is production-ready.

### Compliance Check

- Coding Standards: ✓ Follows project conventions, linter passes
- Project Structure: ✓ Files in correct locations per architecture
- Testing Strategy: ✓ 23 tests with mocked dependencies
- All ACs Met: ✓ All 7 acceptance criteria fully implemented

### Requirements Traceability

| AC | Requirement | Implementation | Test Coverage |
|----|-------------|----------------|---------------|
| 1 | GET modules list | `list_ai_modules()` | ✓ `test_modules_returns_list`, `test_modules_returns_404_*` |
| 2 | GET single module | `get_ai_module()` | ✓ `test_module_returns_full_data`, `test_module_returns_404_*` |
| 3 | GET vocabulary (full/by module) | `get_ai_vocabulary()` with `?module` | ✓ `test_vocabulary_*` (3 tests) |
| 4 | GET vocabulary audio URL | `get_vocabulary_audio_url()` | ✓ `test_audio_*` (4 tests) |
| 5 | GET processing metadata | `get_ai_metadata()` | ✓ `test_metadata_*` (3 tests) |
| 6 | Proper caching headers | Cache-Control on all responses | ✓ `TestCacheHeaders` class (2 tests) |
| 7 | 404 if not processed | All endpoints check for None | ✓ Multiple 404 tests |

### Improvements Checklist

- [x] All endpoints implemented per requirements
- [x] Authentication enforced on all endpoints
- [x] Input validation on language codes (whitelist)
- [x] Path traversal prevention on word parameter
- [x] Presigned URLs for audio (no direct file exposure)
- [x] Comprehensive test coverage (23 tests)
- [ ] Consider pagination for vocabulary endpoint (future enhancement - could return 100+ words)
- [ ] `audio_exists()` method implemented but unused - remove or document intended use

### Security Review

**Status: PASS**

- ✓ All endpoints require Bearer token authentication (JWT or API key)
- ✓ Language code validation uses whitelist approach (12 supported languages)
- ✓ Word parameter validated via regex `^[\w\-]+$` to prevent path traversal
- ✓ Audio files served via presigned MinIO URLs (1-hour expiry), not proxied
- ✓ No hardcoded secrets or sensitive data exposure

### Performance Considerations

**Status: PASS**

- ✓ Cache-Control headers enable client-side caching
- ✓ Tiered TTLs (60s-3600s) balance freshness vs performance
- ✓ Presigned URLs offload audio delivery to MinIO
- Note: Large vocabulary responses could benefit from pagination (future enhancement)

### Files Modified During Review

None - no refactoring was required.

### Gate Status

Gate: **PASS** → docs/qa/gates/10.11-ai-data-retrieval-api.yml

### Recommended Status

✓ **Ready for Done** - All acceptance criteria met, tests passing, code quality excellent.

